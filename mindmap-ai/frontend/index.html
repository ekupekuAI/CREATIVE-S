<!DOCTYPE html>
<html lang='en'>
<head>
  <meta charset='UTF-8' />
  <meta name='viewport' content='width=device-width, initial-scale=1.0' />
  <title>AI MindGraph Pro - Advanced NLP Visualizer</title>
  <script src='https://unpkg.com/vis-network/standalone/umd/vis-network.min.js'></script>
  <link href='https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap' rel='stylesheet'>
  <link rel="stylesheet" href="../../css/ui-effects.css">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Poppins', 'Inter', sans-serif;
      background: linear-gradient(135deg, #cdd6e3, #bfc8d8, #b4bfd3);
      min-height: 100vh;
      overflow-x: hidden;
      position: relative;
    }

    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(circle at 20% 80%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),
        radial-gradient(circle at 80% 20%, rgba(255, 119, 198, 0.3) 0%, transparent 50%),
        radial-gradient(circle at 40% 40%, rgba(120, 255, 198, 0.2) 0%, transparent 50%);
      animation: float 20s ease-in-out infinite;
      z-index: -1;
    }

    @keyframes float {
      0%, 100% { transform: translateY(0px) rotate(0deg); }
      33% { transform: translateY(-20px) rotate(120deg); }
      66% { transform: translateY(10px) rotate(240deg); }
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }

    .header {
      text-align: center;
      margin-bottom: 40px;
      animation: slideInDown 1s ease-out;
    }

    @keyframes slideInDown {
      from { transform: translateY(-50px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }

    h1 {
      font-size: 3.5rem;
      font-weight: 700;
      background: linear-gradient(45deg, #fff, #e0e7ff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 10px;
      text-shadow: 0px 1px 2px rgba(0,0,0,0.25);
    }

    .subtitle {
      font-size: 1.2rem;
      color: rgba(255, 255, 255, 0.8);
      font-weight: 300;
      text-shadow: 0px 1px 2px rgba(0,0,0,0.25);
    }

    .main-content {
      display: grid;
      grid-template-columns: 1fr 3fr;
      gap: 30px;
      margin-bottom: 30px;
    }

    .control-panel {
      background: rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border-radius: 20px;
      padding: 30px;
      border: 1px solid rgba(255,255,255,0.25);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      animation: slideInLeft 1s ease-out 0.2s both;
    }

    @keyframes slideInLeft {
      from { transform: translateX(-50px); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }

    .input-section {
      margin-bottom: 30px;
    }

    .input-section h3 {
      color: #1f2937;
      margin-bottom: 15px;
      font-size: 1.3rem;
      font-weight: 500;
      text-shadow: 0px 1px 2px rgba(0,0,0,0.25);
    }

    textarea {
      width: 100%;
      min-height: 120px;
      padding: 20px;
      border: none;
      border-radius: 15px;
      background: rgba(255, 255, 255, 0.95);
      color: #333;
      font-size: 1rem;
      font-family: inherit;
      resize: vertical;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    }

    textarea:focus {
      outline: none;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.3), 0 4px 20px rgba(0, 0, 0, 0.15);
      transform: translateY(-2px);
    }

    .options-section {
      margin-bottom: 30px;
    }

    .options-section h3 {
      color: #1f2937;
      margin-bottom: 15px;
      font-size: 1.3rem;
      font-weight: 500;
      text-shadow: 0px 1px 2px rgba(0,0,0,0.25);
    }

    .option-group {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 15px;
    }

    .option-btn {
      padding: 12px 20px;
      border: none;
      border-radius: 25px;
      background: rgba(255, 255, 255, 0.2);
      color: white;
      font-size: 0.9rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.3s ease;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.3);
      text-shadow: 0px 1px 2px rgba(0,0,0,0.25);
    }

    .option-btn:hover {
      background: rgba(255, 255, 255, 0.3);
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    }

    .option-btn.active {
      background: linear-gradient(45deg, #667eea, #764ba2);
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
    }

    .generate-btn {
      width: 100%;
      padding: 18px;
      border: none;
      border-radius: 15px;
      background: linear-gradient(45deg, #667eea, #764ba2);
      color: white;
      font-size: 1.1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
      position: relative;
      overflow: hidden;
      text-shadow: 0px 1px 2px rgba(0,0,0,0.25);
    }

    .generate-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: left 0.5s;
    }

    .generate-btn:hover::before {
      left: 100%;
    }

    .generate-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
    }

    .generate-btn:disabled {
      opacity: 0.7;
      cursor: not-allowed;
      transform: none;
    }

    .download-btn {
      width: 100%;
      padding: 18px;
      border: none;
      border-radius: 15px;
      background: linear-gradient(45deg, #10b981, #059669);
      color: white;
      font-size: 1.1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(16, 185, 129, 0.3);
      position: relative;
      overflow: hidden;
      display: none;
      margin-top: 15px;
      text-shadow: 0px 1px 2px rgba(0,0,0,0.25);
    }

    .download-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: left 0.5s;
    }

    .download-btn:hover::before {
      left: 100%;
    }

    .download-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(16, 185, 129, 0.4);
    }

    .visualization-panel {
      background: rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border-radius: 20px;
      padding: 30px;
      border: 1px solid rgba(255,255,255,0.25);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      animation: slideInRight 1s ease-out 0.4s both;
      position: relative;
      min-height: 720px; /* Increased to accommodate larger graph */
    }

    @keyframes slideInRight {
      from { transform: translateX(50px); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }

    .loading-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      border-radius: 20px;
      z-index: 10;
      animation: fadeIn 0.3s ease;
    }

    .loading-spinner {
      width: 60px;
      height: 60px;
      border: 4px solid #e0e7ff;
      border-top: 4px solid #667eea;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .loading-text {
      color: #667eea;
      font-size: 1.1rem;
      font-weight: 500;
      text-align: center;
    }

    .result-section {
      margin-top: 20px;
    }

    .result-title {
      color: #333;
      font-size: 1.5rem;
      font-weight: 600;
      margin-bottom: 15px;
      text-align: center;
    }

    .keywords-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 10px;
    }

    .keyword-tag {
      background: linear-gradient(45deg, #667eea, #764ba2);
      color: white;
      padding: 8px 15px;
      border-radius: 20px;
      font-size: 0.9rem;
      font-weight: 500;
      text-align: center;
      box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
      animation: bounceIn 0.5s ease both;
    }

    .summary-text {
      background: rgba(255, 255, 255, 0.9);
      padding: 25px;
      border-radius: 15px;
      color: #333;
      line-height: 1.6;
      font-size: 1rem;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      animation: fadeInUp 0.5s ease both;
    }

    .summary-section {
      background: rgba(255, 255, 255, 0.9);
      padding: 20px;
      border-radius: 15px;
      margin-bottom: 15px;
      color: #333;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      animation: fadeInUp 0.5s ease both;
    }

    .summary-section h4 {
      margin-bottom: 10px;
      color: #667eea;
      font-weight: 600;
    }

    .summary-section p {
      line-height: 1.6;
      margin-bottom: 10px;
    }

    .summary-section ul {
      padding-left: 20px;
    }

    .summary-section li {
      margin-bottom: 5px;
      line-height: 1.5;
    }

    .keywords-list {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .keyword {
      background: #667eea;
      color: white;
      padding: 5px 10px;
      border-radius: 20px;
      font-size: 0.9rem;
      font-weight: 500;
    }

    @keyframes bounceIn {
      0% { transform: scale(0.3); opacity: 0; }
      50% { transform: scale(1.05); }
      70% { transform: scale(0.9); }
      100% { transform: scale(1); opacity: 1; }
    }

    @keyframes fadeInUp {
      from { transform: translateY(30px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    #graph {
      width: 100%;
      height: 650px; /* Increased height for better visualization */
      background: rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    }

    .footer {
      text-align: center;
      margin-top: 40px;
      color: rgba(255, 255, 255, 0.7);
      font-size: 0.9rem;
      animation: fadeIn 2s ease 1s both;
    }

    @media (max-width: 768px) {
      .main-content {
        grid-template-columns: 1fr;
        gap: 20px;
      }
      
      h1 {
        font-size: 2.5rem;
      }
      
      .control-panel, .visualization-panel {
        padding: 20px;
      }
    }

    .node-glow {
      animation: glowPulse 2s infinite ease-in-out;
    }

    @keyframes glowPulse {
      0% { box-shadow: 0 0 5px rgba(255,255,255,0.4); }
      50% { box-shadow: 0 0 22px rgba(255,255,255,0.9); }
      100% { box-shadow: 0 0 5px rgba(255,255,255,0.4); }
    }

    #graph canvas:hover {
      transition: filter 0.3s ease;
      filter: drop-shadow(0 0 12px rgba(255,255,255,0.4));
    }
  </style>
</head>

<body>
  <div class='container'>
    <div class='header'>
      <h1> AI MindGraph Pro</h1>
      <p class='subtitle'>Transform your text into stunning visual insights with advanced AI</p>
    </div>

    <div class='main-content'>
      <div class='control-panel'>
        <div class='input-section'>
          <h3> Input Your Text</h3>
          <textarea id='description' placeholder='Paste any article, notes, or content here...'></textarea>
        </div>

        <div class='options-section'>
          <h3> Choose Visualization</h3>
          <div class='option-group'>
            <button class='option-btn active' data-mode='auto'> Auto Detect</button>
            <button class='option-btn' data-mode='flowchart'> Flowchart</button>
            <button class='option-btn' data-mode='mindgraph'> Mind Graph</button>
            <button class='option-btn' data-mode='keywords'> Keywords</button>
            <button class='option-btn' data-mode='summary'> Summary</button>
          </div>

          <h3> Options</h3>
          <div class='option-group'>
            <button class='option-btn' id='web-research'> Web Research</button>
          </div>
        </div>

        <button class='generate-btn' id='generate'>
           Generate Visualization
        </button>

        <div class='export-options' id='export-options' style='display: none; margin-top: 15px;'>
          <label style='color: white; font-size: 0.9rem; margin-right: 10px;'>Export Format:</label>
          <select id='export-format' style='padding: 8px 12px; border-radius: 8px; border: none; background: rgba(255,255,255,0.9); color: #333; font-size: 0.9rem;'>
            <option value='png'>PNG (High Quality)</option>
            <option value='svg'>SVG (Scalable)</option>
          </select>
        </div>

        <button class='download-btn' id='download'>
           Download High-Quality Image
        </button>
      </div>

      <div class='visualization-panel'>
        <div id='graph'></div>
        <div class='result-section' id='result-section' style='display: none;'></div>
      </div>
    </div>

    <div class='footer'>
      <p>Powered by Advanced AI  Real-time Processing  Beautiful Visualizations</p>
    </div>
  </div>

  <script>
  const textarea = document.getElementById('description');
  const generateBtn = document.getElementById('generate');
  const downloadBtn = document.getElementById('download');
  const graphContainer = document.getElementById('graph');
  const resultSection = document.getElementById('result-section');
  const optionBtns = document.querySelectorAll('.option-btn');
  const webResearchBtn = document.getElementById('web-research');

  let currentMode = 'auto';  // Default to auto detection
  let network = null;
  let isWebResearchEnabled = false;
  let isFitting = false; // Prevent multiple fit operations

  const networkOptions = {
    flowchart: {
      nodes: {
        shape: 'box',
        size: 25,
        font: { 
          color: '#1f2937', 
          size: 14, 
          face: 'Inter', 
          align: 'center',
          multi: true,
          bold: { color: '#1f2937', size: 14, face: 'Inter', vadjust: 0, mod: 'bold' }
        },
        borderWidth: 3,
        borderWidthSelected: 5,
        shadow: { enabled: true, color: 'rgba(0,0,0,0.2)', size: 8, x: 3, y: 3 },
        margin: 15,
        widthConstraint: { minimum: 120, maximum: 300 },
        heightConstraint: { minimum: 50, valign: 'middle' },
        labelHighlightBold: true
      },
      edges: {
        color: { color: '#64748b', highlight: '#3b82f6', hover: '#3b82f6' },
        arrows: { 
          to: { 
            enabled: true, 
            scaleFactor: 1.4, 
            type: 'arrow'
          } 
        },
        smooth: { 
          type: 'cubicBezier', 
          forceDirection: 'vertical',
          roundness: 0.4
        },
        shadow: { enabled: true, color: 'rgba(0,0,0,0.1)', size: 5, x: 2, y: 2 },
        font: { 
          size: 12, 
          color: '#374151', 
          background: 'rgba(255,255,255,0.95)', 
          align: 'middle',
          strokeWidth: 1,
          strokeColor: '#e5e7eb'
        },
        width: 3,
        selectionWidth: 6,
        hoverWidth: 4
      },
      layout: {
        hierarchical: {
          direction: 'UD',  // Up-Down layout for flowchart
          sortMethod: 'directed',
          nodeSpacing: 180,  // Reduced spacing for better fit
          levelSeparation: 150,  // Reduced vertical space
          treeSpacing: 160,  // Space between parallel branches
          blockShifting: true,
          edgeMinimization: true,
          parentCentralization: false,
          shakeTowards: 'roots'  // Align towards root
        }
      },
      physics: { enabled: false },  // Keep physics disabled for clean flowchart layout
      interaction: { 
        hover: true, 
        dragNodes: false,  // Keep nodes fixed for clean layout
        zoomView: true,
        navigationButtons: true,
        keyboard: { enabled: true, speed: { x: 10, y: 10, zoom: 0.02 } },
        tooltipDelay: 300,
        hideEdgesOnDrag: false,
        hideEdgesOnZoom: false
      },
      groups: {
        startEnd: {
          shape: 'circle',
          color: { background: '#10b981', border: '#059669' },
          font: { color: '#ffffff', size: 16, face: 'Inter' }
        },
        process: {
          shape: 'box',
          color: { background: '#3b82f6', border: '#2563eb' },
          font: { color: '#ffffff', size: 14, face: 'Inter' }
        },
        decision: {
          shape: 'diamond',
          color: { background: '#ef4444', border: '#dc2626' },
          font: { color: '#ffffff', size: 14, face: 'Inter' }
        },
        inputOutput: {
          shape: 'box',
          color: { background: '#f59e0b', border: '#d97706' },
          font: { color: '#1f2937', size: 14, face: 'Inter' }
        }
      }
    },
    mindgraph: {
      nodes: {
        shape: 'dot',
        size: 25,
        font: {
          color: '#1f2937',
          size: 14,
          face: 'Inter',
          align: 'center',
          multi: true
        },
        borderWidth: 2,
        shadow: {
          enabled: true,
          color: 'rgba(0,0,0,0.15)',
          size: 4,
          x: 2,
          y: 2
        },
        margin: 10
      },

      edges: {
        color: { color: '#94a3b8', highlight: '#3b82f6', hover: '#3b82f6' },

        arrows: {
          to: { enabled: true, scaleFactor: 1.2, type: 'arrow' }
          // color removed (illegal in vis)
        },

        smooth: { type: 'curvedCW', roundness: 0.4 },

        shadow: {
          enabled: true,
          color: 'rgba(0,0,0,0.1)',
          size: 3,
          x: 1,
          y: 1
        },

        width: 2
      },

      layout: {
        improvedLayout: false,
        hierarchical: false
      },

      physics: {
        enabled: false
      },

      interaction: {
        hover: true,
        dragNodes: true,
        zoomView: true,
        zoomSpeed: 0.4,
        navigationButtons: true,
        keyboard: {
          enabled: true,
          speed: { x: 10, y: 10, zoom: 0.02 }
        }
      },

      groups: {
        central: {
          shape: "circle",
          size: 60,
          color: {
            background: "linear-gradient(135deg, #4f46e5, #7c3aed)",
            border: "#ffffff"
          },
          borderWidth: 3,
          font: {
            color: "#ffffff",
            size: 22,
            face: "Inter"
          },
          shadow: {
            enabled: true,
            color: "rgba(0,0,0,0.4)",
            size: 10,
            x: 3,
            y: 3
          }
        },

        branch: {
          shape: "box",
          size: 40,
          color: {
            background: "linear-gradient(135deg, #10b981, #34d399)",
            border: "#065f46"
          },
          borderWidth: 3,
          font: {
            color: "#ffffff",
            size: 18,
            face: "Inter"
          },
          shadow: {
            enabled: true,
            color: "rgba(0,0,0,0.25)",
            size: 8,
            x: 2,
            y: 2
          }
        },

        subbranch: {
          shape: "ellipse",
          size: 30,
          color: {
            background: "linear-gradient(135deg, #f59e0b, #fbbf24)",
            border: "#b45309"
          },
          borderWidth: 2,
          font: {
            color: "#111827",
            size: 15,
            face: "Inter"
          },
          shadow: {
            enabled: true,
            color: "rgba(0,0,0,0.2)",
            size: 6,
            x: 2,
            y: 2
          }
        }
      }
    },
  };

  optionBtns.forEach(btn => {
    btn.addEventListener('click', () => {
      if (btn.id === 'web-research') return;

      optionBtns.forEach(b => {
        if (b.id !== 'web-research') b.classList.remove('active');
      });

      btn.classList.add('active');
      currentMode = btn.dataset.mode;

      if (currentMode === 'keywords' || currentMode === 'summary') {
        graphContainer.style.display = 'none';
        resultSection.style.display = 'block';
        downloadBtn.style.display = 'none'; // Hide download button for non-visual modes
        document.getElementById('export-options').style.display = 'none'; // Hide export options
      } else {
        graphContainer.style.display = 'block';
        resultSection.style.display = 'none';
        if (currentMode === 'auto') {
          downloadBtn.style.display = 'none'; // Hide until we know the actual mode
          document.getElementById('export-options').style.display = 'none';
        }
      }
    });
  });

  webResearchBtn.addEventListener('click', () => {
    isWebResearchEnabled = !isWebResearchEnabled;
    webResearchBtn.classList.toggle('active');
  });

  generateBtn.addEventListener('click', async () => {
    const text = textarea.value.trim();
    if (!text) {
      alert('Please enter some text to analyze!');
      return;
    }

    generateBtn.disabled = true;
    generateBtn.textContent = 'Analyzing...';
    downloadBtn.style.display = 'none'; // Hide download button during processing
    document.getElementById('export-options').style.display = 'none'; // Hide export options
    showLoading();

    try {
      // First, classify the text to get recommended mode
      const classifyResponse = await fetch('http://localhost:8000/api/mindmap/classify', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ text })
      });

      if (!classifyResponse.ok) throw new Error('Classification failed: ' + classifyResponse.status);
      const classifyData = await classifyResponse.json();

      // Use manual mode if explicitly selected, otherwise use recommended
      let selectedMode = currentMode;
      if (currentMode === 'auto') {
        // Auto mode - use classification result
        selectedMode = classifyData.mode;
      } else if (currentMode === 'mindgraph') {
        selectedMode = 'mindgraph';  // Use mindgraph consistently
      }

      generateBtn.textContent = 'Processing...';

      let data;

      if (selectedMode === 'summary') {
        // Get structured summary from backend
        const summaryResponse = await fetch('http://localhost:8000/api/mindmap/summarize', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ text })
        });

        if (!summaryResponse.ok) throw new Error('Summary failed: ' + summaryResponse.status);
        data = await summaryResponse.json();
      } else {
        // Send to backend for other modes
        const response = await fetch('http://localhost:8000/api/mindmap/analyze', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            text,
            mode: selectedMode,
            enable_web: isWebResearchEnabled
          })
        });

        if (!response.ok) throw new Error('Analysis failed: ' + response.status);
        data = await response.json();

        if (data.error) throw new Error(data.error);
      }

      if (selectedMode === 'keywords') {
        displayKeywords(data.keywords || []);
      } else if (selectedMode === 'summary') {
        displayStructuredSummary(data);
      } else {
        if (!Array.isArray(data.nodes) || !Array.isArray(data.edges))
          throw new Error('Invalid graph data');
        renderVisualization(data.nodes, data.edges);
        // Show download button for visual modes
        downloadBtn.style.display = 'block';
        document.getElementById('export-options').style.display = 'block';
      }

    } catch (err) {
      alert('Error: ' + err.message);
    } finally {
      generateBtn.disabled = false;
      generateBtn.textContent = 'Generate Visualization';
      hideLoading();
    }
  });

  downloadBtn.addEventListener('click', () => {
    if (!network) {
      alert('No visualization to download!');
      return;
    }

    try {
      const canvas = graphContainer.querySelector('canvas');
      if (!canvas) {
        throw new Error('Canvas not found');
      }

      const exportFormat = document.getElementById('export-format').value;
      const timestamp = Date.now();

      if (exportFormat === 'svg') {
        // Create SVG export
        const svgContent = createSVGExport(network, canvas.width, canvas.height);
        const blob = new Blob([svgContent], { type: 'image/svg+xml' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = `mindgraph-${currentMode}-${timestamp}.svg`;
        link.click();
        URL.revokeObjectURL(link.href);
      } else {
        // PNG export with high quality - simple and reliable
        const link = document.createElement('a');
        link.download = `mindgraph-${currentMode}-${timestamp}.png`;
        link.href = canvas.toDataURL('image/png', 1.0);
        link.click();
      }

    } catch (err) {
      console.error('Download error:', err);
      alert('Error downloading image: ' + err.message);
    }
  });

  function showLoading() {
    const overlay = document.createElement('div');
    overlay.className = 'loading-overlay';
    overlay.id = 'loading-overlay';
    overlay.innerHTML = `
      <div class='loading-spinner'></div>
      <div class='loading-text'>AI is analyzing your text...</div>
    `;
    document.querySelector('.visualization-panel').appendChild(overlay);
  }

  function hideLoading() {
    const overlay = document.getElementById('loading-overlay');
    if (overlay) overlay.remove();
  }

  function displayKeywords(keywords) {
    resultSection.innerHTML = `
      <div class='result-title'>Extracted Keywords</div>
      <div class='keywords-grid'>
        ${keywords.map((keyword, index) =>
          `<div class='keyword-tag' style='animation-delay:${index * 0.1}s'>${keyword}</div>`
        ).join('')}
      </div>
    `;
  }

  function displaySummary(summaryJson) {
    let summary;
    try {
      summary = JSON.parse(summaryJson);
    } catch (e) {
      // If not JSON, display as plain text
      resultSection.innerHTML = `
        <div class='result-title'>AI-Generated Summary</div>
        <div class='summary-text'>${summaryJson}</div>
      `;
      return;
    }

    resultSection.innerHTML = `
      <div class='result-title'>${summary.title || 'AI-Generated Summary'}</div>
      <div class='summary-section'>
        <h4>Short Summary</h4>
        <p>${summary.summary_short || ''}</p>
      </div>
      <div class='summary-section'>
        <h4>Medium Summary</h4>
        <p>${summary.summary_medium || ''}</p>
      </div>
      <div class='summary-section'>
        <h4>Detailed Summary</h4>
        <p>${summary.summary_detailed || ''}</p>
      </div>
      <div class='summary-section'>
        <h4>Key Points</h4>
        <ul>
          ${summary.key_points ? summary.key_points.map(point => `<li>${point}</li>`).join('') : ''}
        </ul>
      </div>
      <div class='summary-section'>
        <h4>Keywords</h4>
        <div class='keywords-list'>
          ${summary.keywords ? summary.keywords.map(keyword => `<span class='keyword'>${keyword}</span>`).join('') : ''}
        </div>
      </div>
    `;
  }

  function displayStructuredSummary(data) {
    resultSection.innerHTML = `
      <div class='result-title'>${data.title || 'AI-Generated Summary'}</div>
      <div class='summary-section'>
        <h4>Short Summary</h4>
        <p>${data.summary_short || ''}</p>
      </div>
      <div class='summary-section'>
        <h4>Medium Summary</h4>
        <p>${data.summary_medium || ''}</p>
      </div>
      <div class='summary-section'>
        <h4>Detailed Summary</h4>
        <p>${data.summary_detailed || ''}</p>
      </div>
      <div class='summary-section'>
        <h4>Key Points</h4>
        <ul>
          ${data.key_points ? data.key_points.map(point => `<li>${point}</li>`).join('') : ''}
        </ul>
      </div>
      <div class='summary-section'>
        <h4>Keywords</h4>
        <div class='keywords-list'>
          ${data.keywords ? data.keywords.map(keyword => `<span class='keyword'>${keyword}</span>`).join('') : ''}
        </div>
      </div>
    `;
  }

  function generateSummary(text) {
    // Clean and normalize text
    const cleanedText = text.replace(/\s+/g, ' ').trim();
    
    // Split into sentences (basic implementation)
    const sentences = cleanedText.split(/[.!?]+/).filter(s => s.trim().length > 0);
    
    // Identify main topic (first sentence or longest)
    const mainTopic = sentences[0] || cleanedText.substring(0, 100);
    
    // Identify secondary concepts (other sentences)
    const secondaryConcepts = sentences.slice(1);
    
    // Score sentences (simple: length + position)
    const scoredSentences = sentences.map((sentence, index) => ({
      text: sentence.trim(),
      score: sentence.length + (sentences.length - index) * 10
    })).sort((a, b) => b.score - a.score);
    
    // Remove redundant (simple duplicate removal)
    const uniqueSentences = [];
    const seen = new Set();
    for (const sent of scoredSentences) {
      const lower = sent.text.toLowerCase();
      if (!seen.has(lower)) {
        seen.add(lower);
        uniqueSentences.push(sent);
      }
    }
    
    // Generate summaries
    const topSentences = uniqueSentences.slice(0, 5);
    
    // Short summary (1-2 lines)
    const summaryShort = topSentences.slice(0, 2).map(s => s.text).join('. ') + '.';
    
    // Medium summary (4-6 lines)
    const summaryMedium = topSentences.slice(0, 4).map(s => s.text).join('. ') + '.';
    
    // Detailed summary (paragraph)
    const summaryDetailed = topSentences.map(s => s.text).join('. ') + '.';
    
    // Key points (bullet points)
    const keyPoints = topSentences.slice(0, 5).map(s => s.text);
    
    // Extract keywords (simple: frequent words)
    const words = cleanedText.toLowerCase().match(/\b\w{4,}\b/g) || [];
    const wordFreq = {};
    words.forEach(word => wordFreq[word] = (wordFreq[word] || 0) + 1);
    const keywords = Object.entries(wordFreq)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 10)
      .map(([word]) => word);
    
    // Title (first few words)
    const title = cleanedText.split(' ').slice(0, 5).join(' ') + '...';
    
    return {
      title,
      summary_short: summaryShort,
      summary_medium: summaryMedium,
      summary_detailed: summaryDetailed,
      key_points: keyPoints,
      keywords
    };
  }

function renderFlowchart(nodes, edges) {
  // Calculate dynamic sizing based on text length and apply appropriate styling
  const visNodes = nodes.map(node => {
    const label = node.label || node.id;
    const labelLength = label.length;
    
    // Dynamic sizing based on text length
    let width = Math.max(120, Math.min(300, labelLength * 8 + 40)); // 8px per character + padding
    let height = Math.max(50, Math.ceil(labelLength / 25) * 20 + 30); // Multi-line height calculation
    
    // Determine node group based on mode and content
    let group = 'process'; // default for flowchart
    
    // Flowchart logic
    if (node.label === 'Start' || node.label === 'End') {
      group = 'startEnd';
    } else if (node.shape === 'diamond' || label.toLowerCase().includes('decision')) {
      group = 'decision';
    } else if (label.toLowerCase().includes('input') || label.toLowerCase().includes('output') || node.shape === 'parallelogram') {
      group = 'inputOutput';
    }
    
    return {
      id: node.id,
      label: label,
      group: group,
      level: node.level || 0,
      shape: node.shape || 'box',
      color: node.color || '#3b82f6',
      font: { 
        size: (labelLength > 50 ? 12 : (group === 'startEnd' ? 16 : 14)),
        color: (group === 'startEnd') ? '#ffffff' : '#1f2937',
        align: 'center',
        multi: true,
        face: 'Inter'
      },
      widthConstraint: { minimum: width, maximum: width },
      heightConstraint: { minimum: height, valign: 'middle' },
      margin: 15,
      borderWidth: 3,
      shadow: { enabled: true, color: 'rgba(0,0,0,0.15)', size: 6, x: 2, y: 2 }
    };
  });

  const visEdges = edges.map(edge => ({
    from: edge.from || edge.source,
    to: edge.to || edge.target,
    label: edge.label || edge.relation,
    arrows: edge.arrows || { to: { enabled: true, scaleFactor: 1.4, type: 'arrow' } },
    color: edge.color || { color: '#64748b', highlight: '#3b82f6', hover: '#3b82f6' },
    font: edge.font || { 
      size: 12, 
      color: '#374151', 
      background: 'rgba(255,255,255,0.95)', 
      align: 'middle',
      strokeWidth: 1,
      strokeColor: '#e5e7eb'
    },
    width: edge.width || 3,
    smooth: { 
      type: 'cubicBezier', 
      forceDirection: 'vertical',
      roundness: 0.4
    },
    shadow: { enabled: true, color: 'rgba(0,0,0,0.1)', size: 3, x: 1, y: 1 }
  }));

  const data = {
    nodes: new vis.DataSet(visNodes),
    edges: new vis.DataSet(visEdges)
  };

  if (network) network.destroy();
  
  // Use flowchart options
  const options = networkOptions.flowchart;
  network = new vis.Network(graphContainer, data, options);
  
  // Fit the network to view after stabilization with smooth animation
  if (!isFitting) {
    isFitting = true;
    setTimeout(() => {
      if (network) {
        network.fit({
          animation: {
            duration: 1000,
            easingFunction: 'easeInOutQuad'
          }
        });
      }
      setTimeout(() => { isFitting = false; }, 1100);
    }, 100);
  }

  resultSection.style.display = 'none';
  graphContainer.style.display = 'block';
  
  // Show download button and export options after visualization is rendered
  downloadBtn.style.display = 'block';
  document.getElementById('export-options').style.display = 'block';
}

// ---------- RAINBOW PALETTE FOR BRANCHES ----------
const RAINBOW = [
  "#ff6b6b", "#ff922b", "#f4d35e", "#63e6be", "#4dabf7",
  "#9775fa", "#f783ac"
];

function getRainbowColor(index) {
  return RAINBOW[index % RAINBOW.length];
}

function renderVisualization(nodes, edges) {
  if (currentMode !== "mindgraph") {
    // Use your normal flowchart rendering
    return renderFlowchart(nodes, edges);
  }

  // Clear existing
  if (network) network.destroy();

  const centerX = 0;
  const centerY = 0;

  // Separate nodes into levels
  let centralNode = nodes.find(n => Number(n.level) === 0);

  // SAFETY FIX: if no central node, create one
  if (!centralNode) {
    centralNode = {
      id: "central_auto",
      label: "Central Topic",
      level: 0
    };
    nodes.unshift(centralNode);
  }

  const categories = nodes.filter(n => Number(n.level) === 1);
  const subnodes = nodes.filter(n => Number(n.level) === 2);

  // Position Central Node
  centralNode.x = centerX;
  centralNode.y = centerY;
  centralNode.group = "central";
  centralNode.shape = "circle";

  // Radial Layout Settings
  const categoryRadius = 350;   // distance from center for categories
  const subRadius = 160;        // distance from category for subnodes

  // Position Categories evenly in a circle
  const step = (2 * Math.PI) / categories.length;
  categories.forEach((cat, i) => {
    const angle = i * step;
    const col = getRainbowColor(i);

    cat.x = centerX + categoryRadius * Math.cos(angle);
    cat.y = centerY + categoryRadius * Math.sin(angle);

    cat.group = "branch";
    cat.shape = "box";

    cat.color = {
      background: col,
      border: "#ffffff"
    };
  });

  // Attach subnodes in small circles around their category
  subnodes.forEach(sub => {
    const parent = nodes.find(n => n.id === sub.parent || n.label === sub.parent);
    if (!parent) return;

    const angle = Math.random() * Math.PI * 2;
    sub.x = parent.x + subRadius * Math.cos(angle);
    sub.y = parent.y + subRadius * Math.sin(angle);

    sub.group = "subbranch";
    sub.shape = "ellipse";
    
    // inherit parent color
    sub.color = {
      background: parent.color?.background || "#ffd166",
      border: "#ffffff"
    };
  });

  // Build vis DataSets
  const visNodes = new vis.DataSet(
    nodes.map(n => ({
      id: n.id,
      label: n.label,
      x: n.x,
      y: n.y,
      group: n.group,
      font: { size: 16, face: "Inter" },
      shape: n.shape
    }))
  );

  const visEdges = new vis.DataSet(
    edges.map(e => ({
      from: e.from,
      to: e.to,
      arrows: "to",
      color: "#64748b",
      smooth: { type: "curvedCW", roundness: 0.3 }
    }))
  );

  // Create network with GRAVITY PHYSICS (movable nodes)
  network = new vis.Network(graphContainer, { nodes: visNodes, edges: visEdges }, {
    physics: {
      enabled: true,
      barnesHut: {
        gravitationalConstant: -2000,
        centralGravity: 0.5,
        springLength: 150,
        springConstant: 0.05,
        damping: 0.09,
        avoidOverlap: 0.1
      },
      minVelocity: 0.75,
      solver: 'barnesHut',
      stabilization: {
        enabled: true,
        iterations: 100,
        updateInterval: 25,
        onlyDynamicEdges: false,
        fit: true
      }
    },
    interaction: {
      dragNodes: true,
      zoomView: true,
      navigationButtons: true,
      keyboard: { enabled: true, speed: { x: 10, y: 10, zoom: 0.02 } }
    },
    groups: {
      central: {
        shape: "circle",
        size: 60,
        color: {
          background: "linear-gradient(135deg, #4f46e5, #7c3aed)",
          border: "#ffffff"
        },
        borderWidth: 3,
        font: {
          color: "#ffffff",
          size: 22,
          face: "Inter",
          bold: true
        },
        shadow: {
          enabled: true,
          color: "rgba(0,0,0,0.4)",
          size: 10,
          x: 3,
          y: 3
        }
      },

      branch: {
        shape: "box",
        size: 40,
        color: {
          background: "linear-gradient(135deg, #10b981, #34d399)",
          border: "#065f46"
        },
        borderWidth: 3,
        font: {
          color: "#ffffff",
          size: 18,
          face: "Inter"
        },
        shadow: {
          enabled: true,
          color: "rgba(0,0,0,0.25)",
          size: 8,
          x: 2,
          y: 2
        }
      },

      subbranch: {
        shape: "ellipse",
        size: 30,
        color: {
          background: "linear-gradient(135deg, #f59e0b, #fbbf24)",
          border: "#b45309"
        },
        borderWidth: 2,
        font: {
          color: "#111827",
          size: 15,
          face: "Inter"
        },
        shadow: {
          enabled: true,
          color: "rgba(0,0,0,0.2)",
          size: 6,
          x: 2,
          y: 2
        }
      }
    }
  });

  // Fit to screen with animation
  network.fit({
    animation: { duration: 800, easingFunction: "easeInOutQuad" }
  });

  // POP ANIMATION ON LOAD
  network.once("stabilizationIterationsDone", () => {
    const scaleUp = 1.3;
    const scaleDown = 1.0;

    network.moveTo({
      scale: scaleUp,
      animation: { duration: 500, easingFunction: "easeInOutQuad" }
    });

    setTimeout(() => {
      network.moveTo({
        scale: scaleDown,
        animation: { duration: 800, easingFunction: "easeInOutQuad" }
      });
    }, 500);
  });

  // Add Glow on Active Hover Node
  network.on("hoverNode", function (params) {
    const nodeId = params.node;
    network.body.nodes[nodeId].options.shadow = {
      enabled: true,
      color: "rgba(255,255,255,0.9)",
      size: 25,
      x: 0,
      y: 0
    };
    network.redraw();
  });

  network.on("blurNode", function (params) {
    const nodeId = params.node;
    if (network.body.nodes[nodeId]) {
      network.body.nodes[nodeId].options.shadow = {
        enabled: true,
        color: "rgba(0,0,0,0.2)",
        size: 6,
        x: 2,
        y: 2
      };
      network.redraw();
    }
  });
}

  function createSVGExport(network, width, height) {
    // Get network data
    const nodes = network.body.data.nodes.get();
    const edges = network.body.data.edges.get();
    const positions = network.getPositions();
    const viewPosition = network.getViewPosition();
    const scale = network.getScale();

    let svg = `<svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg">
      <rect width="100%" height="100%" fill="white"/>
      <defs>
        <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
          <polygon points="0 0, 10 3.5, 0 7" fill="#64748b"/>
        </marker>
      </defs>`;

    // Draw edges first (so they appear behind nodes)
    edges.forEach(edge => {
      const fromPos = positions[edge.from];
      const toPos = positions[edge.to];

      if (fromPos && toPos) {
        // Convert to canvas coordinates (center-based)
        const x1 = (fromPos.x - viewPosition.x) / scale + width/2;
        const y1 = (fromPos.y - viewPosition.y) / scale + height/2;
        const x2 = (toPos.x - viewPosition.x) / scale + width/2;
        const y2 = (toPos.y - viewPosition.y) / scale + height/2;

        svg += `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="#64748b" stroke-width="2" marker-end="url(#arrowhead)"/>`;

        // Add edge label if present
        if (edge.label) {
          const midX = (x1 + x2) / 2;
          const midY = (y1 + y2) / 2;
          svg += `<text x="${midX}" y="${midY}" text-anchor="middle" font-family="Inter" font-size="12" fill="#6b7280">${edge.label}</text>`;
        }
      }
    });

    // Draw nodes
    nodes.forEach(node => {
      const pos = positions[node.id];
      if (pos) {
        // Convert to canvas coordinates (center-based)
        const x = (pos.x - viewPosition.x) / scale + width/2;
        const y = (pos.y - viewPosition.y) / scale + height/2;
        const size = node.size || 25;

        // Node shape
        let shapeElement = '';
        if (node.shape === 'circle') {
          shapeElement = `<circle cx="${x}" cy="${y}" r="${size}" fill="${node.color || '#3b82f6'}" stroke="#ffffff" stroke-width="2"/>`;
        } else if (node.shape === 'diamond') {
          const points = `${x},${y-size} ${x+size},${y} ${x},${y+size} ${x-size},${y}`;
          shapeElement = `<polygon points="${points}" fill="${node.color || '#ef4444'}" stroke="#ffffff" stroke-width="2"/>`;
        } else {
          // Default to rectangle/box
          shapeElement = `<rect x="${x-size}" y="${y-size}" width="${size*2}" height="${size*2}" fill="${node.color || '#3b82f6'}" stroke="#ffffff" stroke-width="2" rx="5"/>`;
        }

        svg += shapeElement;

        // Node label
        const fontSize = node.font?.size || 14;
        const textColor = node.font?.color || '#ffffff';
        svg += `<text x="${x}" y="${y}" text-anchor="middle" dominant-baseline="middle" font-family="Inter" font-size="${fontSize}" fill="${textColor}" font-weight="500">${node.label}</text>`;
      }
    });

    svg += '</svg>';
    return svg;
  }

  document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => {
      const els = document.querySelectorAll('.control-panel, .visualization-panel');
      els.forEach((el, index) => {
        el.style.opacity = '0';
        el.style.transform = 'translateY(20px)';
        setTimeout(() => {
          el.style.transition = 'all 0.6s ease';
          el.style.opacity = '1';
          el.style.transform = 'translateY(0)';
        }, index * 200);
      });
    }, 100);
  });

</script>

</body>
</html>
